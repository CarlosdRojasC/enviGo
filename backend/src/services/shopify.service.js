const axios = require('axios');
const Order = require('../models/Order');
const Channel = require('../models/Channel');
const Company = require('../models/Company');
const mongoose = require('mongoose');
const ShipdayService = require('./shipday.service');

class ShopifyService {
  // Construir URL base de la API
  static getApiUrl(channel) {
    return `https://${channel.store_url.replace('https://', '').replace('http://', '')}/admin/api/${process.env.SHOPIFY_API_VERSION || '2024-01'}`;
  }
  
  // Construir headers de autenticaci√≥n
  static getHeaders(channel) {
    return {
      'X-Shopify-Access-Token': channel.api_key || channel.api_secret,
      'Content-Type': 'application/json'
    };
  }

  // üèòÔ∏è NUEVA FUNCI√ìN: Normalizar nombre de comuna
  static normalizeCommune(commune) {
    if (!commune) return '';
    
    // Limpiar y normalizar
    let normalized = commune.trim();
    
    // Mapeo de variaciones comunes de nombres de comunas que manejas
    const communeMap = {
      // Macul
      'macul': 'Macul',
      
      // San Miguel
      'san miguel': 'San Miguel',
      'sanmiguel': 'San Miguel',
      
      // Santiago Centro
      'santiago centro': 'Santiago Centro',
      'santiago': 'Santiago Centro',
      'centro': 'Santiago Centro',
      'stgo centro': 'Santiago Centro',
      'stgo': 'Santiago Centro',
      
      // La Florida
      'la florida': 'La Florida',
      'florida': 'La Florida',
      'laflorida': 'La Florida',
      
      // Pe√±alol√©n
      'penalolen': 'Pe√±alol√©n',
      'pe√±alolen': 'Pe√±alol√©n',
      'penalol√©n': 'Pe√±alol√©n',
      'pe√±alol√©n': 'Pe√±alol√©n',
      
      // Las Condes
      'las condes': 'Las Condes',
      'las conde': 'Las Condes',
      'conde': 'Las Condes',
      'condes': 'Las Condes',
      
      // Vitacura
      'vitacura': 'Vitacura',
      'vita': 'Vitacura',
      
      // Quinta Normal
      'quinta normal': 'Quinta Normal',
      'quintanormal': 'Quinta Normal',
      '5ta normal': 'Quinta Normal',
      
      // Independencia
      'independencia': 'Independencia',
      'indep': 'Independencia',
      
      // Recoleta
      'recoleta': 'Recoleta',
      
      // Huechuraba
      'huechuraba': 'Huechuraba',
      
      // Quilicura
      'quilicura': 'Quilicura',
      
      // Estaci√≥n Central
      'estacion central': 'Estaci√≥n Central',
      'estaci√≥n central': 'Estaci√≥n Central',
      'estacioncentral': 'Estaci√≥n Central',
      
      // √ëu√±oa
      'nunoa': '√ëu√±oa',
      '√±unoa': '√ëu√±oa',
      'noa': '√ëu√±oa',
      
      // La Reina
      'la reina': 'La Reina',
      'reina': 'La Reina',
      'lareina': 'La Reina',
      
      // San Joaqu√≠n
      'san joaquin': 'San Joaqu√≠n',
      'sanjoaquin': 'San Joaqu√≠n',
      'san joaqu√≠n': 'San Joaqu√≠n',
      
      // Pedro Aguirre Cerda
      'pedro aguirre cerda': 'Pedro Aguirre Cerda',
      'pedroaguirrecerda': 'Pedro Aguirre Cerda',
      'pac': 'Pedro Aguirre Cerda',
      
      // Cerrillos
      'cerrillos': 'Cerrillos',
      
      // Renca
      'renca': 'Renca',
      
      // La Granja
      'la granja': 'La Granja',
      'granja': 'La Granja',
      'lagranja': 'La Granja',
      
      // La Cisterna
      'la cisterna': 'La Cisterna',
      'cisterna': 'La Cisterna',
      'lacisterna': 'La Cisterna',
      
      // San Ram√≥n
      'san ramon': 'San Ram√≥n',
      'sanramon': 'San Ram√≥n',
      'san ram√≥n': 'San Ram√≥n',
      
      // Cerro Navia
      'cerro navia': 'Cerro Navia',
      'cerronavia': 'Cerro Navia'
    };
    
    const lowerNormalized = normalized.toLowerCase();
    return communeMap[lowerNormalized] || normalized;
  }

  static validateShippingAddress(shopifyOrder) {
  const errors = [];
  
  // Verificar que exista al menos una direcci√≥n
  if (!shopifyOrder.shipping_address && !shopifyOrder.billing_address) {
    errors.push('Pedido sin direcci√≥n de env√≠o ni facturaci√≥n');
    return { isValid: false, errors };
  }
  
  // Priorizar shipping_address, luego billing_address
  const address = shopifyOrder.shipping_address || shopifyOrder.billing_address;
  
  // Validar campos cr√≠ticos de direcci√≥n
  if (!address.address1 || address.address1.trim().length < 10) {
    errors.push('Direcci√≥n muy corta o faltante (m√≠nimo 10 caracteres)');
  }
  
  if (!address.city || address.city.trim().length < 3) {
    errors.push('Comuna/Ciudad faltante o inv√°lida');
  }
  
  // Validar que sea de Chile (opcional pero recomendado)
  if (address.country && address.country.toLowerCase() !== 'chile' && address.country.toLowerCase() !== 'cl') {
    errors.push('Solo se procesan pedidos de Chile');
  }
  
  // Validar informaci√≥n del destinatario
  if (!address.first_name && !address.last_name && !address.name) {
    errors.push('Nombre del destinatario faltante');
  }
  
  if (!address.phone || address.phone.trim().length < 8) {
    errors.push('Tel√©fono del destinatario faltante o inv√°lido');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    address
  };
}

  // üèòÔ∏è NUEVA FUNCI√ìN: Validar si comuna est√° permitida
  static isCommuneAllowed(orderCommune, allowedCommunes) {
    if (!allowedCommunes || allowedCommunes.length === 0) {
      return true; // Si no hay restricciones, permitir todas
    }
    
    if (!orderCommune) {
      return false; // Si no hay comuna en el pedido, rechazar
    }
    
    const normalizedOrderCommune = this.normalizeCommune(orderCommune).toLowerCase();
    
    return allowedCommunes.some(allowedCommune => 
      this.normalizeCommune(allowedCommune).toLowerCase() === normalizedOrderCommune
    );
  }
  
  // Procesar webhook de Shopify
  static async processWebhook(channelId, webhookData) {
    try {
      console.log('üõçÔ∏è Procesando webhook de Shopify para canal:', channelId);
      
      // 1. Buscar informaci√≥n del canal
      const channel = await Channel.findById(channelId).populate('company_id');
      if (!channel) {
        throw new Error(`Canal ${channelId} no encontrado`);
      }
      
      // üèòÔ∏è NUEVA L√ìGICA: Filtrar por comunas permitidas
      const allowedCommunes = channel.accepted_communes || [];
      const orderCommune = webhookData.shipping_address?.city || webhookData.billing_address?.city || '';
      
      if (!this.isCommuneAllowed(orderCommune, allowedCommunes)) {
        console.log(`üö´ Pedido #${webhookData.name} rechazado. Comuna "${orderCommune}" no est√° permitida para el canal "${channel.channel_name}".`);
        console.log(`üìã Comunas permitidas: ${allowedCommunes.join(', ')}`);
        return { success: true, message: 'Pedido rechazado por filtro de comuna' };
      }
      
      console.log(`‚úÖ Pedido #${webhookData.name} aceptado. Comuna "${orderCommune}" est√° permitida.`);
      
      // 2. Crear el pedido en la base de datos
      const order = await this.createOrderFromWebhook(channel, webhookData);
      
      // 3. Opcional: Crear autom√°ticamente en Shipday si est√° configurado
      if (channel.auto_create_shipday && order.status === 'processing') {
        try {
          await ShipdayService.createOrder(order._id);
          console.log('‚úÖ Pedido creado autom√°ticamente en Shipday');
        } catch (shipdayError) {
          console.error('‚ö†Ô∏è Error al crear pedido en Shipday:', shipdayError);
          // No detener el proceso por errores de Shipday
        }
      }
      
      return order;
    } catch (error) {
      console.error('‚ùå Error procesando webhook de Shopify:', error);
      throw error;
    }
  }
  
  // Crear pedido desde webhook
  static async createOrderFromWebhook(channel, shopifyOrder) {
  try {
    console.log(`üîç Validando pedido ${shopifyOrder.name} antes de crear...`);
    
    // NUEVA VALIDACI√ìN: Verificar direcci√≥n ANTES de procesar
    const addressValidation = this.validateShippingAddress(shopifyOrder);
    
    if (!addressValidation.isValid) {
      console.log(`üö´ Pedido ${shopifyOrder.name} RECHAZADO por direcci√≥n inv√°lida:`);
      addressValidation.errors.forEach(error => console.log(`   - ${error}`));
      
      // Opcional: Registrar el rechazo para estad√≠sticas
      await this.logRejectedOrder(shopifyOrder, channel._id, addressValidation.errors);
      
      return null; // No crear el pedido
    }
    
    // Verificar si el pedido ya existe
    const existingOrder = await Order.findOne({
      channel_id: channel._id,
      external_order_id: shopifyOrder.id.toString()
    });
    
    if (existingOrder) {
      console.log('üîÑ Actualizando pedido existente:', shopifyOrder.name);
      return await this.updateExistingOrder(existingOrder, shopifyOrder);
    }
    
    console.log(`‚úÖ Pedido ${shopifyOrder.name} pas√≥ validaci√≥n, creando...`);
    
    // Obtener informaci√≥n de la empresa para pricing
    const company = await Company.findById(channel.company_id);
    const fixedShippingCost = company?.price_per_order || 0;
    
    // Usar la direcci√≥n validada
    const validatedAddress = addressValidation.address;
    
    // Crear nuevo pedido
    const newOrder = new Order({
      company_id: channel.company_id,
      channel_id: channel._id,
      external_order_id: shopifyOrder.id.toString(),
      order_number: shopifyOrder.name,
      
      // Informaci√≥n del cliente (mejorada con datos de direcci√≥n validada)
      customer_name: this.getCustomerName(shopifyOrder, validatedAddress),
      customer_email: shopifyOrder.email || shopifyOrder.customer?.email || '',
      customer_phone: validatedAddress.phone || shopifyOrder.phone || shopifyOrder.customer?.phone || '',

      delivery_type: (shopifyOrder.shipping_lines && shopifyOrder.shipping_lines.length > 0) ? 'shipping' : 'pickup',

      // Direcci√≥n validada
      shipping_address: this.formatValidatedAddress(validatedAddress),
      shipping_commune: this.normalizeCommune(validatedAddress.city),
      shipping_state: validatedAddress.province || validatedAddress.province_code || 'Regi√≥n Metropolitana',
      shipping_zip: validatedAddress.zip,
      
      // Informaci√≥n financiera
      total_amount: parseFloat(shopifyOrder.total_price) || 0,
      shipping_cost: fixedShippingCost,
      currency: shopifyOrder.currency,
      
      // Estado y fechas
      status: this.mapOrderStatus(shopifyOrder),
      order_date: new Date(shopifyOrder.created_at),
      
      // Items del pedido
      items: this.mapOrderItems(shopifyOrder.line_items),
      items_count: shopifyOrder.line_items?.length || 0,
      
      // Datos adicionales
      notes: shopifyOrder.note,
      raw_data: shopifyOrder,
      
      // Metadatos
      created_at: new Date(),
      updated_at: new Date()
    });
    
    const savedOrder = await newOrder.save();
    console.log(`‚úÖ Pedido creado: ${savedOrder.order_number} - Comuna: ${savedOrder.shipping_commune}`);
    
    return savedOrder;
    
  } catch (error) {
    console.error('‚ùå Error creando pedido desde webhook:', error);
    throw error;
  }
}
  static async notifyOrderEnRoute(channel, order, trackingUrl) {
  try {
    console.log(`üöó Notificando a Shopify que repartidor va en camino para pedido #${order.order_number}`);
    
    const shopifyOrderId = order.external_order_id;
    
    // Crear fulfillment (esto notifica al cliente)
    const fulfillmentData = {
      tracking_number: order.order_number,
      tracking_company: 'enviGo',
      notify_customer: true, // ‚úÖ Esto env√≠a email al cliente
      tracking_urls: trackingUrl ? [trackingUrl] : []
    };
    
    const response = await axios.post(
      `${this.getApiUrl(channel)}/orders/${shopifyOrderId}/fulfillments.json`,
      { fulfillment: fulfillmentData },
      { headers: this.getHeaders(channel) }
    );
    
    console.log('‚úÖ Shopify notificado: repartidor en camino');
    return { success: true, fulfillment_id: response.data.fulfillment.id };
    
  } catch (error) {
    console.error('‚ùå Error notificando Shopify:', error);
    
    if (error.response?.status === 422) {
      console.log('‚ö†Ô∏è Fulfillment ya existe - actualizando tracking');
      // Intentar actualizar fulfillment existente
      return await this.updateExistingFulfillment(channel, shopifyOrderId, trackingUrl);
    }
    
    throw error;
  }
}

// Funci√≥n auxiliar para actualizar fulfillment existente
static async updateExistingFulfillment(channel, shopifyOrderId, trackingUrl) {
  try {
    // Obtener fulfillments existentes
    const response = await axios.get(
      `${this.getApiUrl(channel)}/orders/${shopifyOrderId}/fulfillments.json`,
      { headers: this.getHeaders(channel) }
    );
    
    const fulfillments = response.data.fulfillments;
    if (fulfillments.length > 0) {
      const fulfillmentId = fulfillments[0].id;
      
      // Actualizar el fulfillment con tracking
      await axios.put(
        `${this.getApiUrl(channel)}/orders/${shopifyOrderId}/fulfillments/${fulfillmentId}.json`,
        {
          fulfillment: {
            tracking_urls: trackingUrl ? [trackingUrl] : [],
            notify_customer: true
          }
        },
        { headers: this.getHeaders(channel) }
      );
      
      console.log('‚úÖ Fulfillment existente actualizado con tracking');
      return { success: true };
    }
    
  } catch (error) {
    console.error('‚ùå Error actualizando fulfillment existente:', error);
    return { success: false };
  }
}
  
  // Actualizar pedido existente
  static async updateExistingOrder(existingOrder, shopifyOrder) {
    try {
      // Obtener informaci√≥n de la empresa para pricing
      const company = await Company.findById(existingOrder.company_id);
      const fixedShippingCost = company?.price_per_order || 0;
      
      const updates = {
        status: this.mapOrderStatus(shopifyOrder),
        total_amount: parseFloat(shopifyOrder.total_price) || 0,
        shipping_cost: fixedShippingCost,
        // üèòÔ∏è NUEVA L√ìGICA: Actualizar comuna
        shipping_commune: this.normalizeCommune(shopifyOrder.shipping_address?.city || shopifyOrder.billing_address?.city || ''),
        shipping_state: shopifyOrder.shipping_address?.province || shopifyOrder.billing_address?.province || 'Regi√≥n Metropolitana',
        items: this.mapOrderItems(shopifyOrder.line_items),
        items_count: shopifyOrder.line_items?.length || 0,
        notes: shopifyOrder.note,
        raw_data: shopifyOrder,
        updated_at: new Date()
      };
      
      // Solo actualizar delivery_date si se marca como entregado
      if (updates.status === 'delivered' && !existingOrder.delivery_date) {
        updates.delivery_date = new Date();
      }
      
      const updatedOrder = await Order.findByIdAndUpdate(
        existingOrder._id,
        updates,
        { new: true }
      );
      
      console.log(`üîÑ Pedido actualizado: ${updatedOrder.order_number} - Comuna: ${updatedOrder.shipping_commune}`);
      return updatedOrder;
    } catch (error) {
      console.error('‚ùå Error actualizando pedido:', error);
      throw error;
    }
  }
  
  // Sincronizar pedidos hist√≥ricos
static async syncOrders(channel, dateFrom, dateTo) {
  try {
    console.log('üîÑ Sincronizando pedidos de Shopify con validaci√≥n de direcciones...');
    
    let ordersImported = 0;
    let ordersRejected = 0;
    let addressRejected = 0;
    let currentPage = 1;
    const limit = 50; // ‚úÖ REDUCIR L√çMITE para evitar timeouts
    let hasMoreOrders = true;
    
    // Obtener comunas permitidas
    const allowedCommunes = channel.accepted_communes || [];
    console.log(`üìã Comunas permitidas: ${allowedCommunes.join(', ')}`);
    
    // ‚úÖ VALIDAR Y CORREGIR FECHAS
    let correctedDateFrom = dateFrom;
    let correctedDateTo = dateTo;
    
    // Si dateFrom es futuro, corregir a fecha pasada
    if (correctedDateFrom && new Date(correctedDateFrom) > new Date()) {
      correctedDateFrom = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(); // 30 d√≠as atr√°s
      console.log(`‚ö†Ô∏è Fecha desde era futura, corregida a: ${correctedDateFrom}`);
    }
    
    // Si dateTo es futuro, corregir a ahora
    if (correctedDateTo && new Date(correctedDateTo) > new Date()) {
      correctedDateTo = new Date().toISOString();
      console.log(`‚ö†Ô∏è Fecha hasta era futura, corregida a: ${correctedDateTo}`);
    }
    
    while (hasMoreOrders) {
      try {
        console.log(`üìÑ Obteniendo p√°gina ${currentPage}...`);
        
        // ‚úÖ CONSTRUIR PAR√ÅMETROS CORRECTAMENTE
        const params = new URLSearchParams();
        if (correctedDateFrom) {
          params.append('created_at_min', correctedDateFrom);
        }
        if (correctedDateTo) {
          params.append('created_at_max', correctedDateTo);
        }
        params.append('status', 'any');
        params.append('limit', limit.toString());
        
        // ‚úÖ NO USAR 'page' - Shopify lo maneja autom√°ticamente con links
        
        console.log(`üîç URL consultada: ${this.getApiUrl(channel)}/orders.json?${params}`);
        
        // ‚úÖ AGREGAR TIMEOUT Y HEADERS MEJORADOS
        const response = await axios.get(
          `${this.getApiUrl(channel)}/orders.json?${params}`,
          { 
            headers: this.getHeaders(channel),
            timeout: 30000, // 30 segundos timeout
            validateStatus: function (status) {
              return status >= 200 && status < 500; // No lanzar error en 4xx
            }
          }
        );
        
        // ‚úÖ MANEJAR ERRORES HTTP ESPEC√çFICOS
        if (response.status === 400) {
          console.error('‚ùå Error 400 - Bad Request desde Shopify:', response.data);
          throw new Error(`Par√°metros inv√°lidos: ${JSON.stringify(response.data)}`);
        }
        
        if (response.status === 401) {
          console.error('‚ùå Error 401 - No autorizado');
          throw new Error('Token de acceso inv√°lido o expirado');
        }
        
        if (response.status === 429) {
          console.log('‚è≥ Rate limit alcanzado, esperando 2 segundos...');
          await new Promise(resolve => setTimeout(resolve, 2000));
          continue; // Reintentar la misma p√°gina
        }
        
        if (!response.data || !response.data.orders) {
          console.error('‚ùå Respuesta inv√°lida de Shopify:', response.data);
          throw new Error('Respuesta inv√°lida de la API');
        }
        
        const orders = response.data.orders;
        console.log(`üì¶ Obtenidos ${orders.length} pedidos en p√°gina ${currentPage}`);
        
        if (!orders || orders.length === 0) {
          console.log('‚úÖ No hay m√°s pedidos para procesar');
          hasMoreOrders = false;
          break;
        }
        
        // Procesar cada pedido con validaci√≥n completa
        for (const shopifyOrder of orders) {
          try {
            // 1. VALIDAR DIRECCI√ìN PRIMERO
            const addressValidation = this.validateShippingAddress(shopifyOrder);
            
            if (!addressValidation.isValid) {
              console.log(`üö´ Pedido ${shopifyOrder.name} rechazado por direcci√≥n: ${addressValidation.errors.join(', ')}`);
              addressRejected++;
              continue;
            }
            
            // 2. VALIDAR COMUNA (solo si la direcci√≥n es v√°lida)
            const orderCommune = addressValidation.address.city;
            
            if (!this.isCommuneAllowed(orderCommune, allowedCommunes)) {
              console.log(`üö´ Pedido ${shopifyOrder.name} rechazado por comuna: "${orderCommune}" no permitida`);
              ordersRejected++;
              continue;
            }
            
            // 3. VERIFICAR SI YA EXISTE
            const existingOrder = await Order.findOne({
              channel_id: channel._id,
              external_order_id: shopifyOrder.id.toString()
            });
            
            if (existingOrder) {
              console.log(`‚è≠Ô∏è Pedido ${shopifyOrder.name} ya existe, omitiendo...`);
              continue;
            }
            
            // 4. CREAR PEDIDO (ya validado)
            await this.createOrderFromWebhook(channel, shopifyOrder);
            ordersImported++;
            console.log(`‚úÖ Pedido ${shopifyOrder.name} importado - Comuna: ${orderCommune}`);
            
          } catch (orderError) {
            console.error(`‚ùå Error procesando pedido ${shopifyOrder.name}:`, orderError);
            ordersRejected++;
          }
        }
        
        // ‚úÖ CONTROL DE P√ÅGINAS MEJORADO
        if (orders.length < limit) {
          // Si obtuvimos menos pedidos que el l√≠mite, no hay m√°s p√°ginas
          hasMoreOrders = false;
        } else {
          // Obtener el √∫ltimo pedido para usar su fecha como punto de partida
          const lastOrder = orders[orders.length - 1];
          correctedDateFrom = lastOrder.created_at;
          currentPage++;
        }
        
        // ‚úÖ PAUSA OBLIGATORIA entre p√°ginas para evitar rate limiting
        if (hasMoreOrders) {
          console.log('‚è≥ Esperando 1 segundo antes de la siguiente p√°gina...');
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
      } catch (pageError) {
        console.error(`‚ùå Error obteniendo p√°gina ${currentPage}:`, pageError.message);
        
        // Si es un error de rate limiting, esperar m√°s tiempo
        if (pageError.response?.status === 429) {
          console.log('‚è≥ Rate limit severo, esperando 5 segundos...');
          await new Promise(resolve => setTimeout(resolve, 5000));
          continue; // Reintentar la misma p√°gina
        }
        
        // Para otros errores, terminar la sincronizaci√≥n
        hasMoreOrders = false;
      }
    }
    
    console.log(`‚úÖ Sincronizaci√≥n completada:`);
    console.log(`   üì¶ Pedidos importados: ${ordersImported}`);
    console.log(`   üö´ Rechazados por comuna: ${ordersRejected}`);
    console.log(`   ‚ùå Rechazados por direcci√≥n: ${addressRejected}`);
    console.log(`   üìä Total procesados: ${ordersImported + ordersRejected + addressRejected}`);
    
    return {
      imported: ordersImported,
      rejected: ordersRejected + addressRejected,
      addressRejected: addressRejected,
      communeRejected: ordersRejected,
      total: ordersImported + ordersRejected + addressRejected
    };
    
  } catch (error) {
    console.error('‚ùå Error en sincronizaci√≥n:', error);
    throw error;
  }
}
  
  // Mapear items del pedido
  static mapOrderItems(lineItems) {
    if (!lineItems || lineItems.length === 0) return [];
    
    return lineItems.map(item => ({
      product_id: item.product_id?.toString(),
      sku: item.sku,
      name: item.name,
      variant: item.variant_title,
      quantity: item.quantity,
      unit_price: parseFloat(item.price) || 0,
      total_price: parseFloat(item.price) * item.quantity || 0,
      image_url: item.image_url
    }));
  }
  
  // Registrar webhooks
  static async registerWebhooks(channel) {
    try {
      console.log('üîó Registrando webhooks de Shopify para canal:', channel.store_url);
      
      const webhookUrl = `${process.env.WEBHOOK_BASE_URL || 'https://your-domain.com'}/api/webhooks/shopify/${channel._id}`;
      
      // Registrar webhook para nuevos pedidos
      await axios.post(
        `${this.getApiUrl(channel)}/webhooks.json`,
        {
          webhook: {
            topic: 'orders/create',
            address: webhookUrl,
            format: 'json'
          }
        },
        { headers: this.getHeaders(channel) }
      );
      
      // Registrar webhook para actualizaciones de pedidos
      await axios.post(
        `${this.getApiUrl(channel)}/webhooks.json`,
        {
          webhook: {
            topic: 'orders/updated',
            address: webhookUrl,
            format: 'json'
          }
        },
        { headers: this.getHeaders(channel) }
      );
      
      // Registrar webhook para pedidos cancelados
      await axios.post(
        `${this.getApiUrl(channel)}/webhooks.json`,
        {
          webhook: {
            topic: 'orders/cancelled',
            address: webhookUrl,
            format: 'json'
          }
        },
        { headers: this.getHeaders(channel) }
      );
      
      console.log('‚úÖ Webhooks registrados exitosamente');
      return true;
    } catch (error) {
      console.error('‚ùå Error registrando webhook Shopify:', error);
      throw error;
    }
  }
  
  // Validar configuraci√≥n del canal
  static async validateChannel(channel) {
    try {
      console.log('üîç Validando configuraci√≥n del canal Shopify...');
      
      // Probar conexi√≥n con la API
      const response = await axios.get(
        `${this.getApiUrl(channel)}/shop.json`,
        { headers: this.getHeaders(channel) }
      );
      
      const shop = response.data.shop;
      
      console.log('‚úÖ Conexi√≥n exitosa con tienda:', shop.name);
      
      return {
        valid: true,
        shop_name: shop.name,
        shop_domain: shop.domain,
        shop_email: shop.email,
        plan: shop.plan_name,
        currency: shop.currency
      };
    } catch (error) {
      console.error('‚ùå Error validando canal:', error);
      
      let errorMessage = 'Error de conexi√≥n';
      if (error.response?.status === 401) {
        errorMessage = 'Token de acceso inv√°lido';
      } else if (error.response?.status === 403) {
        errorMessage = 'Permisos insuficientes';
      } else if (error.response?.status === 404) {
        errorMessage = 'Tienda no encontrada';
      }
      
      return {
        valid: false,
        error: errorMessage,
        details: error.response?.data || error.message
      };
    }
  }
  
  // Helpers
  static getCustomerName(order, validatedAddress = null) {
  // Prioridad: direcci√≥n validada -> customer -> shipping_address -> fallback
  if (validatedAddress && (validatedAddress.first_name || validatedAddress.last_name)) {
    return `${validatedAddress.first_name || ''} ${validatedAddress.last_name || ''}`.trim();
  }
  
  if (validatedAddress && validatedAddress.name) {
    return validatedAddress.name;
  }
  
  if (order.customer) {
    return `${order.customer.first_name || ''} ${order.customer.last_name || ''}`.trim();
  }
  
  if (order.shipping_address) {
    return order.shipping_address.name || 'Cliente';
  }
  
  return 'Cliente';
}
  
  static getShippingAddress(order) {
    if (!order.shipping_address) return '';
    const addr = order.shipping_address;
    return `${addr.address1 || ''} ${addr.address2 || ''}`.trim();
  }
  
  static mapOrderStatus(shopifyOrder) {
    // Cancelado
    if (shopifyOrder.cancelled_at) return 'cancelled';
    
    // Entregado
    if (shopifyOrder.fulfillment_status === 'fulfilled') return 'delivered';
    
    // En proceso
    if (shopifyOrder.fulfillment_status === 'partial') return 'processing';
    if (shopifyOrder.fulfillment_status === 'unfulfilled' && shopifyOrder.financial_status === 'paid') return 'processing';
    
    // Enviado
    if (shopifyOrder.fulfillment_status === 'unfulfilled' && shopifyOrder.financial_status === 'paid') return 'shipped';
    
    // Pendiente por defecto
    return 'pending';
  }
}

module.exports = ShopifyService;